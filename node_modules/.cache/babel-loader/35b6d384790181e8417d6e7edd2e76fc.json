{"ast":null,"code":"var isBuffer = require('is-buffer');\n\nmodule.exports = flatten;\nflatten.flatten = flatten;\nflatten.unflatten = unflatten;\n\nfunction keyIdentity(key) {\n  return key;\n}\n\nfunction flatten(target, opts) {\n  opts = opts || {};\n  const delimiter = opts.delimiter || '.';\n  const maxDepth = opts.maxDepth;\n  const transformKey = opts.transformKey || keyIdentity;\n  const output = {};\n\n  function step(object, prev, currentDepth) {\n    currentDepth = currentDepth || 1;\n    Object.keys(object).forEach(function (key) {\n      const value = object[key];\n      const isarray = opts.safe && Array.isArray(value);\n      const type = Object.prototype.toString.call(value);\n      const isbuffer = isBuffer(value);\n      const isobject = type === '[object Object]' || type === '[object Array]';\n      const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1);\n      }\n\n      output[newKey] = value;\n    });\n  }\n\n  step(target);\n  return output;\n}\n\nfunction unflatten(target, opts) {\n  opts = opts || {};\n  const delimiter = opts.delimiter || '.';\n  const overwrite = opts.overwrite || false;\n  const transformKey = opts.transformKey || keyIdentity;\n  const result = {};\n  const isbuffer = isBuffer(target);\n\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target;\n  } // safely ensure that the key is\n  // an integer.\n\n\n  function getkey(key) {\n    const parsedKey = Number(key);\n    return isNaN(parsedKey) || key.indexOf('.') !== -1 || opts.object ? key : parsedKey;\n  }\n\n  function addKeys(keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key];\n      return result;\n    }, recipient);\n  }\n\n  function isEmpty(val) {\n    const type = Object.prototype.toString.call(val);\n    const isArray = type === '[object Array]';\n    const isObject = type === '[object Object]';\n\n    if (!val) {\n      return true;\n    } else if (isArray) {\n      return !val.length;\n    } else if (isObject) {\n      return !Object.keys(val).length;\n    }\n  }\n\n  target = Object.keys(target).reduce((result, key) => {\n    const type = Object.prototype.toString.call(target[key]);\n    const isObject = type === '[object Object]' || type === '[object Array]';\n\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key];\n      return result;\n    } else {\n      return addKeys(key, result, flatten(target[key], opts));\n    }\n  }, {});\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey);\n    let key1 = getkey(split.shift());\n    let key2 = getkey(split[0]);\n    let recipient = result;\n\n    while (key2 !== undefined) {\n      const type = Object.prototype.toString.call(recipient[key1]);\n      const isobject = type === '[object Object]' || type === '[object Array]'; // do not write over falsey, non-undefined values if overwrite is false\n\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return;\n      }\n\n      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {\n        recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {};\n      }\n\n      recipient = recipient[key1];\n\n      if (split.length > 0) {\n        key1 = getkey(split.shift());\n        key2 = getkey(split[0]);\n      }\n    } // unflatten again for 'messy objects'\n\n\n    recipient[key1] = unflatten(target[key], opts);\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/jackjoliet/Documents/marketplace/front/node_modules/flat/index.js"],"names":["isBuffer","require","module","exports","flatten","unflatten","keyIdentity","key","target","opts","delimiter","maxDepth","transformKey","output","step","object","prev","currentDepth","Object","keys","forEach","value","isarray","safe","Array","isArray","type","prototype","toString","call","isbuffer","isobject","newKey","length","overwrite","result","getkey","parsedKey","Number","isNaN","indexOf","addKeys","keyPrefix","recipient","reduce","isEmpty","val","isObject","split","map","key1","shift","key2","undefined"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,OAAjB;AACAA,OAAO,CAACA,OAAR,GAAkBA,OAAlB;AACAA,OAAO,CAACC,SAAR,GAAoBA,SAApB;;AAEA,SAASC,WAAT,CAAsBC,GAAtB,EAA2B;AACzB,SAAOA,GAAP;AACD;;AAED,SAASH,OAAT,CAAkBI,MAAlB,EAA0BC,IAA1B,EAAgC;AAC9BA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,QAAMC,SAAS,GAAGD,IAAI,CAACC,SAAL,IAAkB,GAApC;AACA,QAAMC,QAAQ,GAAGF,IAAI,CAACE,QAAtB;AACA,QAAMC,YAAY,GAAGH,IAAI,CAACG,YAAL,IAAqBN,WAA1C;AACA,QAAMO,MAAM,GAAG,EAAf;;AAEA,WAASC,IAAT,CAAeC,MAAf,EAAuBC,IAAvB,EAA6BC,YAA7B,EAA2C;AACzCA,IAAAA,YAAY,GAAGA,YAAY,IAAI,CAA/B;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAYJ,MAAZ,EAAoBK,OAApB,CAA4B,UAAUb,GAAV,EAAe;AACzC,YAAMc,KAAK,GAAGN,MAAM,CAACR,GAAD,CAApB;AACA,YAAMe,OAAO,GAAGb,IAAI,CAACc,IAAL,IAAaC,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAA7B;AACA,YAAMK,IAAI,GAAGR,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BR,KAA/B,CAAb;AACA,YAAMS,QAAQ,GAAG9B,QAAQ,CAACqB,KAAD,CAAzB;AACA,YAAMU,QAAQ,GACZL,IAAI,KAAK,iBAAT,IACAA,IAAI,KAAK,gBAFX;AAKA,YAAMM,MAAM,GAAGhB,IAAI,GACfA,IAAI,GAAGN,SAAP,GAAmBE,YAAY,CAACL,GAAD,CADhB,GAEfK,YAAY,CAACL,GAAD,CAFhB;;AAIA,UAAI,CAACe,OAAD,IAAY,CAACQ,QAAb,IAAyBC,QAAzB,IAAqCb,MAAM,CAACC,IAAP,CAAYE,KAAZ,EAAmBY,MAAxD,KACD,CAACxB,IAAI,CAACE,QAAN,IAAkBM,YAAY,GAAGN,QADhC,CAAJ,EAC+C;AAC7C,eAAOG,IAAI,CAACO,KAAD,EAAQW,MAAR,EAAgBf,YAAY,GAAG,CAA/B,CAAX;AACD;;AAEDJ,MAAAA,MAAM,CAACmB,MAAD,CAAN,GAAiBX,KAAjB;AACD,KApBD;AAqBD;;AAEDP,EAAAA,IAAI,CAACN,MAAD,CAAJ;AAEA,SAAOK,MAAP;AACD;;AAED,SAASR,SAAT,CAAoBG,MAApB,EAA4BC,IAA5B,EAAkC;AAChCA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,QAAMC,SAAS,GAAGD,IAAI,CAACC,SAAL,IAAkB,GAApC;AACA,QAAMwB,SAAS,GAAGzB,IAAI,CAACyB,SAAL,IAAkB,KAApC;AACA,QAAMtB,YAAY,GAAGH,IAAI,CAACG,YAAL,IAAqBN,WAA1C;AACA,QAAM6B,MAAM,GAAG,EAAf;AAEA,QAAML,QAAQ,GAAG9B,QAAQ,CAACQ,MAAD,CAAzB;;AACA,MAAIsB,QAAQ,IAAIZ,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BrB,MAA/B,MAA2C,iBAA3D,EAA8E;AAC5E,WAAOA,MAAP;AACD,GAX+B,CAahC;AACA;;;AACA,WAAS4B,MAAT,CAAiB7B,GAAjB,EAAsB;AACpB,UAAM8B,SAAS,GAAGC,MAAM,CAAC/B,GAAD,CAAxB;AAEA,WACEgC,KAAK,CAACF,SAAD,CAAL,IACA9B,GAAG,CAACiC,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CADtB,IAEA/B,IAAI,CAACM,MAHA,GAIHR,GAJG,GAKH8B,SALJ;AAMD;;AAED,WAASI,OAAT,CAAkBC,SAAlB,EAA6BC,SAA7B,EAAwCnC,MAAxC,EAAgD;AAC9C,WAAOU,MAAM,CAACC,IAAP,CAAYX,MAAZ,EAAoBoC,MAApB,CAA2B,UAAUT,MAAV,EAAkB5B,GAAlB,EAAuB;AACvD4B,MAAAA,MAAM,CAACO,SAAS,GAAGhC,SAAZ,GAAwBH,GAAzB,CAAN,GAAsCC,MAAM,CAACD,GAAD,CAA5C;AAEA,aAAO4B,MAAP;AACD,KAJM,EAIJQ,SAJI,CAAP;AAKD;;AAED,WAASE,OAAT,CAAkBC,GAAlB,EAAuB;AACrB,UAAMpB,IAAI,GAAGR,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BiB,GAA/B,CAAb;AACA,UAAMrB,OAAO,GAAGC,IAAI,KAAK,gBAAzB;AACA,UAAMqB,QAAQ,GAAGrB,IAAI,KAAK,iBAA1B;;AAEA,QAAI,CAACoB,GAAL,EAAU;AACR,aAAO,IAAP;AACD,KAFD,MAEO,IAAIrB,OAAJ,EAAa;AAClB,aAAO,CAACqB,GAAG,CAACb,MAAZ;AACD,KAFM,MAEA,IAAIc,QAAJ,EAAc;AACnB,aAAO,CAAC7B,MAAM,CAACC,IAAP,CAAY2B,GAAZ,EAAiBb,MAAzB;AACD;AACF;;AAEDzB,EAAAA,MAAM,GAAGU,MAAM,CAACC,IAAP,CAAYX,MAAZ,EAAoBoC,MAApB,CAA2B,CAACT,MAAD,EAAS5B,GAAT,KAAiB;AACnD,UAAMmB,IAAI,GAAGR,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BrB,MAAM,CAACD,GAAD,CAArC,CAAb;AACA,UAAMwC,QAAQ,GAAIrB,IAAI,KAAK,iBAAT,IAA8BA,IAAI,KAAK,gBAAzD;;AACA,QAAI,CAACqB,QAAD,IAAaF,OAAO,CAACrC,MAAM,CAACD,GAAD,CAAP,CAAxB,EAAuC;AACrC4B,MAAAA,MAAM,CAAC5B,GAAD,CAAN,GAAcC,MAAM,CAACD,GAAD,CAApB;AACA,aAAO4B,MAAP;AACD,KAHD,MAGO;AACL,aAAOM,OAAO,CACZlC,GADY,EAEZ4B,MAFY,EAGZ/B,OAAO,CAACI,MAAM,CAACD,GAAD,CAAP,EAAcE,IAAd,CAHK,CAAd;AAKD;AACF,GAbQ,EAaN,EAbM,CAAT;AAeAS,EAAAA,MAAM,CAACC,IAAP,CAAYX,MAAZ,EAAoBY,OAApB,CAA4B,UAAUb,GAAV,EAAe;AACzC,UAAMyC,KAAK,GAAGzC,GAAG,CAACyC,KAAJ,CAAUtC,SAAV,EAAqBuC,GAArB,CAAyBrC,YAAzB,CAAd;AACA,QAAIsC,IAAI,GAAGd,MAAM,CAACY,KAAK,CAACG,KAAN,EAAD,CAAjB;AACA,QAAIC,IAAI,GAAGhB,MAAM,CAACY,KAAK,CAAC,CAAD,CAAN,CAAjB;AACA,QAAIL,SAAS,GAAGR,MAAhB;;AAEA,WAAOiB,IAAI,KAAKC,SAAhB,EAA2B;AACzB,YAAM3B,IAAI,GAAGR,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+Bc,SAAS,CAACO,IAAD,CAAxC,CAAb;AACA,YAAMnB,QAAQ,GACZL,IAAI,KAAK,iBAAT,IACAA,IAAI,KAAK,gBAFX,CAFyB,CAOzB;;AACA,UAAI,CAACQ,SAAD,IAAc,CAACH,QAAf,IAA2B,OAAOY,SAAS,CAACO,IAAD,CAAhB,KAA2B,WAA1D,EAAuE;AACrE;AACD;;AAED,UAAKhB,SAAS,IAAI,CAACH,QAAf,IAA6B,CAACG,SAAD,IAAcS,SAAS,CAACO,IAAD,CAAT,IAAmB,IAAlE,EAAyE;AACvEP,QAAAA,SAAS,CAACO,IAAD,CAAT,GACE,OAAOE,IAAP,KAAgB,QAAhB,IACA,CAAC3C,IAAI,CAACM,MADN,GACe,EADf,GACoB,EAFtB;AAID;;AAED4B,MAAAA,SAAS,GAAGA,SAAS,CAACO,IAAD,CAArB;;AACA,UAAIF,KAAK,CAACf,MAAN,GAAe,CAAnB,EAAsB;AACpBiB,QAAAA,IAAI,GAAGd,MAAM,CAACY,KAAK,CAACG,KAAN,EAAD,CAAb;AACAC,QAAAA,IAAI,GAAGhB,MAAM,CAACY,KAAK,CAAC,CAAD,CAAN,CAAb;AACD;AACF,KA9BwC,CAgCzC;;;AACAL,IAAAA,SAAS,CAACO,IAAD,CAAT,GAAkB7C,SAAS,CAACG,MAAM,CAACD,GAAD,CAAP,EAAcE,IAAd,CAA3B;AACD,GAlCD;AAoCA,SAAO0B,MAAP;AACD","sourcesContent":["var isBuffer = require('is-buffer')\n\nmodule.exports = flatten\nflatten.flatten = flatten\nflatten.unflatten = unflatten\n\nfunction keyIdentity (key) {\n  return key\n}\n\nfunction flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nfunction unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    ) ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce((result, key) => {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object ? [] : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}