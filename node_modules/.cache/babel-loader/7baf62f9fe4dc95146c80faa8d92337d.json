{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\n\n\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? {\n          type: 'element',\n          element: elementOrOptions\n        } : {\n          type: 'data',\n          data: elementOrOptions\n        };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto'; // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData); // Second argument is Element; use passed in Element\n\n\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          } // Second argument is data or undefined; infer the Element\n\n\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData); // Second argument is Element; handle with element\n\n\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          } // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n\n\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {// when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    }; // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n    // Wraps createToken in order to infer the Element that is being tokenized.\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;","map":{"version":3,"sources":["/Users/jackjoliet/Documents/marketplace/front/node_modules/react-stripe-elements/es/components/inject.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","_react","require","_react2","_interopRequireDefault","_Elements","_Provider","__esModule","default","_objectWithoutProperties","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","inject","WrappedComponent","_class","_temp","componentOptions","undefined","_componentOptions$wit","withRef","_React$Component","props","context","getRegisteredElements","Error","_this","parseElementOrData","elementOrOptions","_frame","id","_componentName","type","element","data","findElement","filterBy","specifiedType","allElements","filteredElements","filter","e","matchingElements","requireElement","wrappedCreateToken","stripe","tokenTypeOrOptions","options","opts","tokenType","rest","createToken","_tokenType","wrappedCreateSource","createSource","wrappedCreatePaymentMethod","paymentMethodType","elementOrData","maybeData","createPaymentMethod","elementOrDataResult","_element","wrappedHandleCardX","method","clientSecret","_element2","tag","state","stripeProps","componentDidMount","_this2","addStripeLoadListener","setState","getWrappedInstance","wrappedInstance","handleCardPayment","handleCardSetup","render","_this3","createElement","elements","ref","c","Component","contextTypes","providerContextTypes","injectContextTypes","displayName","name"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n\n\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? { type: 'element', element: elementOrOptions } : { type: 'data', data: elementOrOptions };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; use passed in Element\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          }\n\n          // Second argument is data or undefined; infer the Element\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; handle with element\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          }\n\n          // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;"]},"metadata":{},"sourceType":"script"}